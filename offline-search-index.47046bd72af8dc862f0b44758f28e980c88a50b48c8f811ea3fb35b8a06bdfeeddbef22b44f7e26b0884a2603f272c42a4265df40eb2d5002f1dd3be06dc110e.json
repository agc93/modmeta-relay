[{"body":"ModMeta Relay is an unofficial implementation of the ModMeta API for interfacing Vortex (or any other ModMeta client) with any non-Nexus mod source. To clarify, this project is not affiliated in any way with Nexus Mods or anyone else, and is an open-source community resource.\nStatus and Limitations The ModMeta Relay project is very new and is largely untested! That being said, I believe it to be functioning at a basic level and both the REST and plugin API are reasonably stable. The following is definitely supported at this point:\n REST GET API: The basic set of GET endpoints for the ModMeta REST API are supported through plugins (see below) Plugins: the ModMeta Relay can load any valid plugin at runtime to support other sources  There's a few things that we specifically don't have (yet):\n POST/Describe API: The Plugin API doesn't currently have any support for saving mod metadata, so the Describe endpoints are not available. Shared Services: Plugins currently have to implement a lot of their own functionality and shared services. This is on the roadmap. Error Handling: The server's error handling is pretty barebones. You might see more errors and odd behaviours surface.  ","excerpt":"ModMeta Relay is an unofficial implementation of the ModMeta API for interfacing Vortex (or any …","ref":"/docs/introduction/","title":"Introduction"},{"body":"The ModMeta API is a simple REST API that at its most basic is an API for providing extended information about mods.\nMore specifically, ModMeta APIs (aka Metaservers) are used to provide additional information and attributes for specific mods based on details of the mod file itself. They do not serve mods, nor make them discoverable, but are specifically for providing metadata for a mod file that a consuming client (Vortex, for example) already knows about.\nmodmeta-db While we refer to it as the \u0026ldquo;ModMeta API\u0026rdquo;, it's not exactly that formalized. The \u0026ldquo;API\u0026rdquo; is just the API surfaced by modmeta-db, the library that Vortex uses to fetch metadata from Nexus Mods and any other configured metaservers.\nThe ModMeta DB is both a client and server implementation that serves metadata from a local database or the Nexus Mods API (by default). If you're just looking for a basic working implementation of the ModMeta pattern, then modmeta-db is the server for you.\nModMeta Relay So what's different about the Relay server? ModMeta Relay intends to be an extensible and configurable server that can provide a ModMeta-compatible API to any other non-Nexus metadata source.\nModMeta Relay doesn't provide any metadata itself! The Relay server does the basics of handling the REST API specifics, query binding and basic validation etc. The actual metadata comes from plugins that the server loads, using a ModMeta-like API. Those plugins can then load metadata from a file, database, API or cache and the Relay server will return the results.\n","excerpt":"The ModMeta API is a simple REST API that at its most basic is an API for providing extended …","ref":"/docs/introduction/basics/","title":"ModMeta Basics"},{"body":"The ModMeta Relay server doesn't store or serve any mod metadata. All the metadata that it returns to clients comes from the currently loaded plugins.\nWhen the Relay server starts up, it will automatically load all the installed plugins (see below) and use them as metadata sources to respond to incoming requests. For each request, the server will query all the available plugins so it's possible for a single request to return multiple different metadata records.\nPlugins can selectively support only parts of the ModMeta API if the source they represent doesn't support it, for example.\nPlugin Loading Plugins are automatically loaded (by default) from a Plugins/ directory in the application root. Plugins must be located in a directory under Plugins with the same name as the plugin assembly (without the .dll). Each plugin can add one or more metadata sources and the server will automatically load all of them and use them to retrieve metadata from requests.\n","excerpt":"The ModMeta Relay server doesn't store or serve any mod metadata. All the metadata that it returns …","ref":"/docs/introduction/plugins/","title":"Relay Plugins"},{"body":" This site includes only the guides for getting started with the ModMeta Relay server and integrating it with mod sources. For help with the \u0026ldquo;main\u0026rdquo; ModMeta DB, check out the Nexus-Mods/modmeta-db repository.\n Welcome to the User Guide for the ModMeta Relay project! Navigate the documentation using the links on the sidebar.\nDocumentation for how to get started with the server, as well as how to build your own plugins, are available. Remember, these docs are also open-source and contributions are always welcome!\n","excerpt":"This site includes only the guides for getting started with the ModMeta Relay server and integrating …","ref":"/docs/","title":"Documentation"},{"body":"Below is a collection of frequent questions and the best answers I can give.\nWhy should I use this? If your integration/extension/game/mod are using Vortex and mods hosted on Nexus Mods, you probably don't need this! ModMeta Relay is specifically intended at making it easier to support non-Nexus mod sources with metadata for Vortex (or any other ModMeta client).\nWhy not just use modmeta-db? Use what you prefer! I was looking for something a little less structured/opinionated than the basic modmeta-db, so designed this as an alternative.\nIdeally, from a client's point of view, it shouldn't even be obvious whether your metaserver is using modmeta-db or the ModMeta Relay.\nHow do I get ModMeta relay to use metadata from ? Unless you know there's already a plugin for the source in question, you will probably need to build one. This is a reasonably simple process and the server should pick up any available plugins at startup.\nThere's a ton of docs on building for/with Relay in the developer docs.\nWhy are there so many references to Beat Saber/BeatVortex in here? Just like how modmeta-db was born out of the Vortex project but is now a separate component, ModMeta Relay was originally a component of BeatVortex until I realised it could be split out as a game- and source-agnostic metadata server. In particular, the BeatVortex plugin is still currently part of this repository, but will be moved at a later date.\n","excerpt":"Below is a collection of frequent questions and the best answers I can give.\nWhy should I use this? …","ref":"/docs/introduction/faq/","title":"Frequently Asked Questions"},{"body":"Ready to get started with ModMeta Relay? Awesome!\nIn general terms, you need to run the server, then install some plugins and configure your client and you should be good to go.\n","excerpt":"Ready to get started with ModMeta Relay? Awesome!\nIn general terms, you need to run the server, then …","ref":"/docs/usage/","title":"Usage"},{"body":"Installing ModMeta Relay There's a couple of ways of running ModMeta Relay at present.\nDocker We automatically build and publish a Docker image for tagged versions to quay.io/modmeta-relay/server. To run the server locally, or on any supported Docker host:\ndocker run -d -p \u0026lt;external-port-here\u0026gt;:80 -v /path/to/your/plugins:/app/plugins quay.io/modmeta-relay/server:\u0026lt;your-version-here\u0026gt; # for example docker run -d -p 8080:80 -v /tmp/modmeta-plugins:/app/plugins quay.io/modmeta-relay/server:0.1.0 The server will be immediately ready to serve mod requests at whatever port you bound to port 80.\n Remember that without any plugins available, the server will still run, but will never return any results!\n Native Packages We also publish native builds for Windows and Linux through GitHub Releases. Find the release you want to use, download the correct .zip for your platform and extract it somewhere. Create a Plugins directory and drop in your plugins, and run ModMetaRelay/ModMetaRelay.exe to start the server. You can change the listening port in appSettings.json, by adding a new key to the configuration:\n\u0026#34;urls\u0026#34;:\u0026#34;https://0.0.0.0:8888\u0026#34; CI or Local Builds If you have the .NET Core runtime already installed, you can use the dotnet-any builds available from the CI builds. Simply download the modmeta-relay artifact from a build and run dotnet ModMetRelay.dll from the dotnet-any directory.\nIf you have the SDK installed, you can build your own pretty easily by cloning the repo and running the following:\ndotnet tool restore dotnet cake --bootstrap dotnet cake --target=Publish This will quickly build all the installation variants locally, into the dist/ folder.\n","excerpt":"Installing ModMeta Relay There's a couple of ways of running ModMeta Relay at present.\nDocker We …","ref":"/docs/usage/installation/","title":"Running the Relay server"},{"body":"ModMeta Plugins If you run the ModMeta Relay server without any plugins configured, you will never get any results! Plugins are responsible for getting mod metadata from whatever source(s) they support.\nInstalling Plugins There's no special process for \u0026ldquo;installing\u0026rdquo; plugins or registering them to the server. Simply place them in a Plugins/ directory beside the server binary and the server will automatically load them. Plugins must be in a directory named the same as the plugin. For example:\nwin-x64 ├── appsettings.Development.json ├── appsettings.json ├── ModMetaRelay.exe ├── ModMetaRelay.pdb └── Plugins └── ModMeta.BeatVortex ├── ModMeta.BeatVortex.dll ├── ModMeta.BeatVortex.deps.json ...  Plugins are loaded only when the server starts! If you've added new plugins, make sure you restart the server to load them.\n Plugin Loading If your plugin doesn't seem to be loading with the server, make sure you check the output/logs. During startup the server will log the locations of plugins it has discovered as well as the paths it is searching.\nPlugin Configuration The Relay server picks up it's configuration from the appSettings.json file in the app directory. If you need to put your plugins in a different location, you can add extra paths for plugins using the PluginPaths option:\n{ ... \u0026#34;Relay\u0026#34;: { \u0026#34;PluginPaths\u0026#34;: [ \u0026#34;/additional/path/to/plugins\u0026#34; ] } ... } Docker The Docker image does not include any plugins by default. You need to include your plugins either using a custom Dockerfile or by simply mounting a plugins folder to the /app/plugins/ directory in your container:\n# for example docker run -d -p 8080:80 -v /tmp/modmeta-plugins:/app/plugins quay.io/modmeta-relay/server:0.1.0 ","excerpt":"ModMeta Plugins If you run the ModMeta Relay server without any plugins configured, you will never …","ref":"/docs/usage/plugins/","title":"Adding Plugins"},{"body":"Metaserver Clients Technically, any client that supports the ModMeta API can use the Relay server to fetch metadata.\nCurrently, Vortex is the only known client to use ModMeta to gather metadata on mods. Other clients will have their own configuration requirements.\nVortex Configuration Metaservers can be added to Vortex through two methods: the Settings menu and extensions.\nSettings To add a new metaserver to Vortex, launch the Settings pane from the sidebar and open the \u0026ldquo;Download\u0026rdquo; tab. You'll see a button near the bottom to \u0026ldquo;Add a Metaserver\u0026rdquo;. Enter the URL of your Relay server and press the tick button on the right hand side to save your new server.\nThe next time Vortex installs a mod, it will query your new metaserver for any metadata about the mod being installed.\n By default, Vortex will only query for metadata using the file key/hash. You can read more about the different requests in the developer docs\n Extensions Extension authors can programmatically add a companion metaserver using the standard IExtensionContext object that your extension uses:\nfunction main(context : IExtensionContext) { ... context.once(() =\u0026gt; { context.api.addMetaServer(\u0026#39;metaserver-id\u0026#39;, { url: \u0026#39;https://your-meta.server.com\u0026#39;}); } ... } ","excerpt":"Metaserver Clients Technically, any client that supports the ModMeta API can use the Relay server to …","ref":"/docs/usage/vortex/","title":"Configuring Metaserver Clients"},{"body":"ModMeta Relay is fully open-source! You can see the full code for the extension (including these docs) on GitHub. Community contributions, fixes and PRs are all welcome! That being said, please read the info below to make all of our lives a bit easier.\nLicensing ModMeta Relay is made available under an MIT License. That means all contributions will also be licensed under the MIT License and all the conditions and limitations that involves.\nDevelopment Environment To work with the ModMeta Relay code, you should only need the .NET Core 3.1 SDK (or higher) and the dotnet CLI configured. Development so far has been done in Visual Studio Code, but any IDE that supports ASP.NET Core should work just fine.\nBuilding Locally To get started building locally, you just need the dotnet CLI installed and available. Since we have a Cake script already set up, just run the following commands to get the build started:\ndotnet tool restore dotnet cake --bootstrap dotnet cake You can also run dotnet cake --target=Publish to build all the packages and images locally.\nFeature Requests ModMeta Relay is a community project, currently built and maintained by a single non-developer. As such, feature requests will be accepted, but I can't provide any level of assurance that any requests will certainly be included.\n","excerpt":"ModMeta Relay is fully open-source! You can see the full code for the extension (including these …","ref":"/docs/developer/","title":"Developer Guide"},{"body":"For plugin authors, the most important things to know about the ModMeta API are the request types and version matching.\nRequest Types Key (by_key) This is the \u0026ldquo;default\u0026rdquo; request used by Vortex, and the only request supported by Nexus Mods. It's also the simplest and requests metadata using a single key: the MD5 hash of the mod archive file. This is super useful for mod sources that store a hash as it's fast, unique and simple.\nLogical File Name (by_name) This is the next-best request, not as specific as file key, but not as vague or intensive as expression. Technically speaking, the logical file name is just a string, but it's usually a string that's semantically important to the mod, such as a unique name for a specific variant of a file.\n Logical file name lookups also use version matching\n File Expression (by_expression) File expressions are, essentially, glob patterns. That makes them very flexible and able to work with practically any file/mod format, but also fragile and intensive to look up, so they are considered a last-ditch option for when the other two are not possible.\n File expression lookups also use version matching\n Version Matching Lookups using logical file name or file expression also use a version string to match specific versions of a file. Version matches are not (necessarily) an exact match and are best specified as a version range.\nIf you've used Node/npm and it's version semantics before, that's how modmeta-db does its version matching. ModMeta Relay tries to match that as closely as possible, but for those curious, existing plugins are using semver.net (Sematnic Versioning for .NET) for version matching.\nThe actual implementation of matching version strings with mod package/file versions is up to plugins, but should always be as specific as practical since returning too many results for a mod can result in conflicting metadata.\n","excerpt":"For plugin authors, the most important things to know about the ModMeta API are the request types …","ref":"/docs/developer/modmeta/","title":"ModMeta API"},{"body":"Introduction At their most basic, a Relay plugin is simply an assembly with an implementation of IModMetaSource (from ModMeta.Core), and optionally an implementation of IModMetaPlugin.\nThe IModMetaSource interface is how the Relay server passes mod metadata queries to your plugin and handles the responses to pass on to the original client.\nImplementing a metadata source In short, add a reference to ModMeta.Core and implement the IModMetaSource interface. The various GetBy* methods are the main entry points the server will call when it gets a request for a mod.\nRequest Type Support Since not every request type might make sense for the metadata source you're building, plugins can choose to only work with certain request types.\nIf your plugin doesn't support a request type at all, not returning it from the SupportedTypes property will cause the server to never even call your plugin for that type. If you only want to skip certain requests, throwing a NotImplementedException will cause the server to ignore your plugin's results for that request.\nAsync and timeouts All configured plugins are called by the server at the same time for each request. If you're familiar with the TPL, we're currently using Task.WhenAll() so your plugin will not be running in a different thread. To keep UX non-awful, there's a hard limit configured of 5 seconds after which any plugins that haven't returned their results are ignored. Given metaservers calls often block installation (as they do in Vortex), making your plugin return data as fast as possible will lead to a much better experience.\nComplex Plugins and IModMetaPlugin If your mod has more advanced requirements or you want to take advantage of runtime DI, you can register your plugin using an implementation of IModMetaPlugin. Much like a metadata source (IModMetaSource), the server will dynamically load your plugin and locate your implementation of IModMetaPlugin.\n If you use IModMetaPlugin, the server will not automatically register your IModMetaSource implementation, you need to do that yourself in the ConfigureServices method.\n Using the IModMetaPlugin.ConfigureServices method, you can register any dependencies you need, read configuration or resolve extra services from the DI container of the host serve. For example:\npublic IServiceCollection ConfigureServices(IServiceCollection services, IConfiguration configuration) { services.AddSingleton\u0026lt;BeatModsClient\u0026gt;(); services.AddSingleton\u0026lt;IModMetaSource, BeatModsSource\u0026gt;(); return services; } ","excerpt":"Introduction At their most basic, a Relay plugin is simply an assembly with an implementation of …","ref":"/docs/developer/plugins/","title":"Building Plugins"},{"body":"  #td-cover-block-0 { background-image: url(/background_hu6011c907b9ad08903644f392d14af901_273872_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/background_hu6011c907b9ad08903644f392d14af901_273872_1920x1080_fill_q75_catmullrom_top.jpg); } }  ModMeta Relay: Extensible Metaserver for Vortex Documentation   GitHub   Nexus Mods   -- An extensible API server for handling mod metadata from anywhere. Fully open-source.\n\n        ModMeta Relay is an extensible server platform for handling mod metadata in clients using the ModMeta format. In particular, this API works as a Metaserver for Vortex, providing more options for mod metadata for non-Nexus mods.\nThis project is unofficial! We have no association with Nexus Mods and is only a community project.\n      Fully Vortex compatible We support the same basic API as modmeta-db, so we're fully compatible with Vortex.\n   Extensible ModMeta Relay includes built-in plugin support for extending the server with any mod source.\n   Contributions welcome! ModMeta Relay is fully open-source and open to community contributions and fixes!\nRead more …\n     Photo by Bill Oxford on Unsplash     ","excerpt":"#td-cover-block-0 { background-image: …","ref":"/","title":"ModMeta Relay"}]